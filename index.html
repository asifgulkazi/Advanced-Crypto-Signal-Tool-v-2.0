<!-- Version 3.8 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Crypto Signal Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; color: #e5e7eb; }
        .signal-card { background-color: #1f2937; border: 1px solid #374151; border-radius: 1rem; }
        .tag { display: inline-block; padding: 0.25rem 0.75rem; border-radius: 9999px; font-weight: 600; font-size: 0.875rem; }
        .tag-long, .tag-strong-buy { background-color: #10b981; color: #ffffff; }
        .tag-short, .tag-strong-sell { background-color: #f43f5e; color: #ffffff; }
        .tag-neutral { background-color: #6b7280; color: #ffffff; }
        .tab { padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 500; cursor: pointer; transition: background-color 0.2s; border: 1px solid transparent; }
        .tab.active { background-color: #3b82f6; color: white; border-color: #3b82f6; }
        .tab:not(.active) { background-color: #374151; color: #d1d5db; }
        .sub-tab { padding: 0.35rem 0.75rem; font-size: 0.875rem; }
        .loader { border: 4px solid #f3f3f3; border-radius: 50%; border-top: 4px solid #3498db; width: 30px; height: 30px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .price-box { transition: background-color 0.1s ease-in-out; }
        .price-up { background-color: rgba(16, 185, 129, 0.3) !important; }
        .price-down { background-color: rgba(244, 63, 94, 0.3) !important; }
        .analysis-section h4 { font-weight: 600; color: #9ca3af; margin-bottom: 0.5rem; border-bottom: 1px solid #374151; padding-bottom: 0.25rem; }
        .analysis-section p { font-size: 0.875rem; color: #d1d5db; }
        .justification-box { background-color: rgba(55, 65, 81, 0.5); border-left: 4px solid #3b82f6; padding: 0.75rem 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 0.75rem; }
        
        .compact-table th, .compact-table td { padding: 0.35rem 0.5rem; text-align: left; font-size: 0.75rem; border-bottom: 1px solid #374151; }
        .compact-table th { color: #9ca3af; background-color: #374151; }
        .compact-table tr:last-child td { border-bottom: none; }
        .compact-table tbody tr:hover { background-color: #374151; }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8">
    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-4 relative">
            <h1 class="text-3xl sm:text-4xl font-bold text-white">Advanced Crypto Signal Tool</h1>
            <p id="analysis-header" class="text-gray-400 mt-2">Real-Time Analysis from Binance</p>
            <div class="absolute top-0 right-0 sm:top-4 sm:right-4 flex items-center space-x-2 text-xs text-gray-400">
                <span>Local</span>
                <label for="timezone-toggle" class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" value="" id="timezone-toggle" class="sr-only peer">
                    <div class="w-9 h-5 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
                <span>UTC</span>
            </div>
        </header>

        <!-- Overall Market Picture Dashboard -->
        <section id="market-overview" class="mb-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            <div class="bg-gradient-to-br from-gray-800 to-gray-900 p-4 rounded-xl border border-gray-700 flex flex-col justify-between h-28">
                <div>
                    <h3 class="text-xs font-medium text-gray-400">Market Cap</h3>
                    <div class="flex items-baseline gap-2">
                        <p id="market-cap" class="text-xl font-semibold text-white">-</p>
                        <p id="market-cap-change" class="text-sm font-medium">-</p>
                    </div>
                </div>
                <div>
                    <h3 class="text-xs font-medium text-gray-400">24h Volume</h3>
                    <div class="flex items-baseline gap-2">
                        <p id="volume-24h" class="text-xl font-semibold text-white">-</p>
                        <p id="volume-change" class="text-sm font-medium">-</p>
                    </div>
                </div>
            </div>
            <div class="bg-gradient-to-br from-gray-800 to-gray-900 p-4 rounded-xl border border-gray-700 flex flex-col justify-between h-28">
                <h3 class="text-xs font-medium text-gray-400">Dominance</h3>
                <div id="dominance-container" class="space-y-1"></div>
                <div id="dominance-bar" class="flex w-full h-2 rounded-full overflow-hidden bg-gray-700"></div>
            </div>
            <div class="bg-gradient-to-br from-gray-800 to-gray-900 p-4 rounded-xl border border-gray-700 relative h-28">
                <h3 class="text-xs font-medium text-gray-400 absolute top-4 left-4">Fear & Greed</h3>
                <canvas id="fear-greed-chart"></canvas>
                <div class="absolute inset-0 flex flex-col items-center justify-center pointer-events-none">
                    <p id="fear-greed-value" class="text-2xl font-bold text-white">-</p>
                    <p id="fear-greed-text" class="text-xs font-medium">-</p>
                </div>
            </div>
            <div class="bg-gradient-to-br from-gray-800 to-gray-900 p-4 rounded-xl border border-gray-700 flex flex-col justify-center h-28">
                <h3 class="text-xs font-medium text-gray-400 mb-2">Market Trend (24h)</h3>
                <div class="space-y-1">
                    <p id="advancers" class="text-xl font-semibold text-green-400">- Advancers</p>
                    <p id="decliners" class="text-xl font-semibold text-red-400">- Decliners</p>
                </div>
            </div>
        </section>

        <div id="trade-type-tabs" class="flex flex-wrap justify-center gap-2 mb-2 border-b border-gray-700 pb-4">
            <button class="tab active" data-type="spot">Spot</button>
            <button class="tab" data-type="futures">Futures</button>
        </div>
        <div id="spot-sub-type-tabs" class="flex flex-wrap justify-center gap-2 mb-4">
            <button class="tab sub-tab active" data-spot-type="day">Day Trading</button>
            <button class="tab sub-tab" data-spot-type="swing">Swing Trading</button>
            <button class="tab sub-tab" data-spot-type="positional">Positional</button>
            <button class="tab sub-tab" data-spot-type="scalp">Scalping</button>
        </div>

        <div id="timeframe-tabs" class="flex flex-wrap justify-center gap-2 mb-6"></div>

        <div class="flex flex-col sm:flex-row gap-2 mb-6 max-w-lg mx-auto">
            <input type="text" id="pair-input" class="w-full px-4 py-2 bg-gray-800 text-white border border-gray-600 rounded-lg" placeholder="e.g., XRPUSDT" value="BTCUSDT">
            <button id="fetch-button" class="w-full sm:w-auto bg-blue-600 text-white font-bold py-2 px-6 rounded-lg flex items-center justify-center">
                <i class="fas fa-search mr-2"></i> Get Signal
            </button>
            <button id="refresh-button" class="w-full sm:w-auto bg-gray-600 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center">
                <i class="fas fa-sync-alt"></i>
            </button>
        </div>

        <div id="signal-container" class="signal-card p-6 sm:p-8 mb-6"></div>
        
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <div id="history-container" class="signal-card p-4 sm:p-6"></div>
            <div id="top-coins-container" class="signal-card p-4 sm:p-6"></div>
            <div id="trending-coins-table-container" class="signal-card p-4 sm:p-6"></div>
            <div id="top-movers-container" class="signal-card p-4 sm:p-6"></div>
            <div id="top-losers-container" class="signal-card p-4 sm:p-6"></div>
        </div>

        <div class="bg-gray-800/50 p-4 mt-8 rounded-lg">
            <h4 class="font-bold text-yellow-300 flex items-center gap-2"><i class="fas fa-exclamation-triangle"></i> Disclaimer</h4>
            <p class="text-sm text-gray-300 mt-2">This signal is for educational purposes only. The crypto market is highly volatile. You are solely responsible for your profits and losses.</p>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const pairInput = document.getElementById('pair-input');
        const fetchButton = document.getElementById('fetch-button');
        const refreshButton = document.getElementById('refresh-button');
        const signalContainer = document.getElementById('signal-container');
        const historyContainer = document.getElementById('history-container');
        const topCoinsContainer = document.getElementById('top-coins-container');
        const topMoversContainer = document.getElementById('top-movers-container');
        const topLosersContainer = document.getElementById('top-losers-container');
        const trendingCoinsTableContainer = document.getElementById('trending-coins-table-container');
        const timeframeTabsContainer = document.getElementById('timeframe-tabs');
        const tradeTypeTabsContainer = document.getElementById('trade-type-tabs');
        const spotSubTypeTabsContainer = document.getElementById('spot-sub-type-tabs');
        const analysisHeader = document.getElementById('analysis-header');
        const marketOverview = document.getElementById('market-overview');
        const timezoneToggle = document.getElementById('timezone-toggle');

        // --- State ---
        let currentInterval = '1h';
        let currentTradeType = 'spot';
        let currentSpotType = 'day';
        let priceSocket = null;
        let btcDominanceChart, fearGreedChart; // Chart instances
        let coinIconMap = {}; // To store symbol -> icon URL mapping
        let currentTimezone = 'local';
        let marketDataCache = null; // Cache for market data

        // --- Timeframe Mappings ---
        const timeframeMappings = {
            all: ['1m', '5m', '15m', '1h', '4h', '8h', '12h', '1d', '1w', '1M'],
            scalp: ['1m', '5m', '15m'],
            day: ['5m', '15m', '1h', '4h'],
            swing: ['1h', '4h', '8h', '12h', '1d'],
            positional: ['1d', '1w', '1M']
        };
        
        // --- CoinGecko ID Mapping ---
        const coinIdMapping = {
            'BTCUSDT': 'bitcoin',
            'ETHUSDT': 'ethereum',
            'XRPUSDT': 'ripple',
            'SOLUSDT': 'solana',
            'BNBUSDT': 'binancecoin',
            'DOGEUSDT': 'dogecoin',
            'ADAUSDT': 'cardano',
            'AVAXUSDT': 'avalanche-2',
            'SHIBUSDT': 'shiba-inu',
            'DOTUSDT': 'polkadot',
            'LINKUSDT': 'chainlink',
            'MATICUSDT': 'matic-network'
        };
        
        // --- Robust Fetch Helper ---
        async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) {
                        return response;
                    }
                    if (response.status >= 400 && response.status < 500) {
                        throw new Error(`Client Error: ${response.status}`);
                    }
                } catch (error) {
                    if (i === retries - 1) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
        }
        
        // --- Time Formatting Helper ---
        function formatTimestamp(timestamp) {
            const date = new Date(timestamp);
            const optionsDate = { month: 'short', day: 'numeric' };
            const optionsTime = { hour: '2-digit', minute:'2-digit', hour12: false };
            const optionsFull = { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute:'2-digit' };
            const optionsFullDate = { year: 'numeric', month: 'short', day: 'numeric' };

            if (currentTimezone === 'utc') {
                optionsDate.timeZone = 'UTC';
                optionsTime.timeZone = 'UTC';
                optionsFull.timeZone = 'UTC';
                optionsFullDate.timeZone = 'UTC';
            }

            return {
                date: date.toLocaleDateString('en-US', optionsDate),
                time: date.toLocaleTimeString('en-US', optionsTime),
                full: date.toLocaleString('en-US', optionsFull),
                fullDate: date.toLocaleDateString('en-US', optionsFullDate)
            };
        }


        // --- Main Signal Generation Function ---
        async function getSignal(pair, interval, tradeType, spotType, fearGreedData) {
            showLoader();
            pair = pair.toUpperCase();
            let headerText = `${pair} | ${interval} | ${tradeType.charAt(0).toUpperCase() + tradeType.slice(1)}`;
            if (tradeType === 'spot') {
                headerText += ` (${spotType.charAt(0).toUpperCase() + spotType.slice(1)})`;
            }
            analysisHeader.textContent = headerText;

            try {
                const coinGeckoId = coinIdMapping[pair];
                if (!coinGeckoId) throw new Error("Coin not supported for full analysis.");

                const [klinesResponse, coinGeckoResponse] = await Promise.all([
                    fetchWithRetry(`https://api.binance.com/api/v3/klines?symbol=${pair}&interval=${interval}&limit=100`),
                    fetchWithRetry(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinGeckoId}`)
                ]);

                const klines = await klinesResponse.json();
                const coinGeckoData = await coinGeckoResponse.json();
                const coinData = coinGeckoData[0];
                
                const lastCandle = klines[klines.length - 1];
                const currentPrice = parseFloat(lastCandle[4]);
                const closePrices = klines.map(k => parseFloat(k[4]));
                const highPrices = klines.map(k => parseFloat(k[2]));
                const lowPrices = klines.map(k => parseFloat(k[3]));
                
                const rsi = calculateRSI(closePrices);
                const { volatilityLabel, atr } = calculateVolatility(highPrices, lowPrices, closePrices);
                const sma20 = calculateSMA(closePrices, 20);
                const sma50 = calculateSMA(closePrices, 50);
                const macd = calculateMACD(closePrices);

                let trendDirection = "Sideways";
                if (currentPrice > sma50 && sma20 > sma50) trendDirection = "Uptrend";
                if (currentPrice < sma50 && sma20 < sma50) trendDirection = "Downtrend";

                let tradeSignal = "Neutral (Hold)";
                let justification = "";
                if (trendDirection === "Uptrend" && rsi < 70 && macd.histogram > 0) {
                    tradeSignal = "Long (Buy)";
                    justification = "The trend is <strong>Up</strong>, key indicators show <strong>bullish momentum</strong>, creating a buying opportunity.";
                } else if (trendDirection === "Downtrend" && rsi > 30 && macd.histogram < 0) {
                    tradeSignal = "Short (Sell)";
                    justification = "The trend is <strong>Down</strong>, key indicators show <strong>bearish momentum</strong>, creating a shorting opportunity.";
                } else {
                    justification = "The market lacks a clear direction (<strong>Sideways</strong>). It's best to wait for stronger confirmation.";
                }
                
                if (tradeType === 'spot' && tradeSignal === 'Short (Sell)') {
                    tradeSignal = "Neutral (Hold)";
                    justification = "The market is in a downtrend. For <strong>Spot trading</strong>, it's safer to wait for a buying opportunity.";
                }
                
                let tradeLevels;
                const shortTermIntervals = ['1m', '5m', '15m'];
                if (spotType === 'scalp' || (spotType === 'day' && shortTermIntervals.includes(interval))) {
                    tradeLevels = calculateAtrSlAndTpLevels(currentPrice, atr, tradeSignal);
                } else {
                    const dailyKlinesUrl = `https://api.binance.com/api/v3/klines?symbol=${pair}&interval=1d&limit=2`;
                    const dailyKlinesResponse = await fetchWithRetry(dailyKlinesUrl);
                    const dailyKlines = await dailyKlinesResponse.json();
                    const prevDayCandle = dailyKlines[0];
                    const prevDayHigh = parseFloat(prevDayCandle[2]);
                    const prevDayLow = parseFloat(prevDayCandle[3]);
                    const prevDayClose = parseFloat(prevDayCandle[4]);
                    tradeLevels = calculatePivotSlAndTpLevels(currentPrice, prevDayHigh, prevDayLow, prevDayClose, tradeSignal);
                }

                const fundamentalAnalysis = generateFundamentalAnalysis(trendDirection, fearGreedData);

                const signalData = {
                    pair, tradeType: tradeSignal, trendDirection, currentPrice,
                    support: tradeLevels.stopLoss,
                    resistance: tradeLevels.tp1,
                    rsi, macd, volatilityLabel,
                    ...tradeLevels,
                    justification,
                    ...fundamentalAnalysis,
                    interval,
                    timestamp: new Date(),
                    ath: coinData.ath,
                    ath_date: coinData.ath_date,
                    ath_change_percentage: coinData.ath_change_percentage,
                    atl: coinData.atl,
                    atl_date: coinData.atl_date,
                    atl_change_percentage: coinData.atl_change_percentage,
                    icon: coinData.image
                };

                updateUI(signalData);
                updateHistoryTable(klines, pair, coinData.image);
                updateMarketAnalysisTables(tradeType);
                startPriceStream(pair);

            } catch (error) {
                showError(error.message);
            }
        }
        
        // --- Calculation Helpers ---
        function calculatePivotSlAndTpLevels(currentPrice, prevDayHigh, prevDayLow, prevDayClose, signal) {
            const P = (prevDayHigh + prevDayLow + prevDayClose) / 3;
            const S1 = (P * 2) - prevDayHigh;
            const R1 = (P * 2) - prevDayLow;
            const R2 = P + (prevDayHigh - prevDayLow);
            const R3 = prevDayHigh + 2 * (P - prevDayLow);

            const stopLoss = S1;
            const tp1 = R1;
            const tp2 = R2;
            const tp3 = R3;

            let risk, reward;
            if (signal.includes('Long')) {
                risk = currentPrice - stopLoss;
                reward = tp1 - currentPrice;
            } else {
                risk = stopLoss - currentPrice;
                reward = currentPrice - tp1;
            }
            const riskRewardRatio = (risk > 0 && reward > 0) ? (reward / risk).toFixed(2) : 0;

            return { tp1, tp2, tp3, stopLoss, riskRewardRatio };
        }
        
        function calculateAtrSlAndTpLevels(currentPrice, atr, signal) {
            const slMultiplier = 1.5;
            const tp1Multiplier = 1.0;
            const tp2Multiplier = 2.0;
            const tp3Multiplier = 3.0;

            let stopLoss, tp1, tp2, tp3;

            if (signal.includes('Long')) {
                stopLoss = currentPrice - (atr * slMultiplier);
                tp1 = currentPrice + (atr * tp1Multiplier);
                tp2 = currentPrice + (atr * tp2Multiplier);
                tp3 = currentPrice + (atr * tp3Multiplier);
            } else {
                stopLoss = currentPrice + (atr * slMultiplier);
                tp1 = currentPrice - (atr * tp1Multiplier);
                tp2 = currentPrice - (atr * tp2Multiplier);
                tp3 = currentPrice - (atr * tp3Multiplier);
            }
            
            let risk, reward;
            if (signal.includes('Long')) {
                risk = currentPrice - stopLoss;
                reward = tp1 - currentPrice;
            } else {
                risk = stopLoss - currentPrice;
                reward = currentPrice - tp1;
            }
            const riskRewardRatio = (risk > 0 && reward > 0) ? (reward / risk).toFixed(2) : 0;

            return { tp1, tp2, tp3, stopLoss, riskRewardRatio };
        }

        function calculateRSI(prices, period = 14) { 
            if (prices.length < period + 1) return 50;
            let gains = 0, losses = 0;
            for (let i = 1; i <= period; i++) {
                const diff = prices[i] - prices[i-1];
                if (diff >= 0) { gains += diff; } else { losses -= diff; }
            }
            let avgGain = gains / period; let avgLoss = losses / period;
            for (let i = period + 1; i < prices.length; i++) {
                const diff = prices[i] - prices[i-1];
                if (diff >= 0) {
                    avgGain = (avgGain * (period - 1) + diff) / period;
                    avgLoss = (avgLoss * (period - 1)) / period;
                } else {
                    avgGain = (avgGain * (period - 1)) / period;
                    avgLoss = (avgLoss * (period - 1) - diff) / period;
                }
            }
            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }
        function calculateSMA(prices, period) { 
            if (prices.length < period) return 0;
            return prices.slice(-period).reduce((a, b) => a + b, 0) / period;
        }
        function calculateMACD(prices, short=12, long=26, signal=9) {
            if (prices.length < long) return { macd: 0, signal: 0, histogram: 0 };
            const ema12 = calculateEMA(prices, 12);
            const ema26 = calculateEMA(prices, 26);
            const macdLine = ema12.map((val, index) => val - ema26[index]);
            const signalLine = calculateEMA(macdLine, 9);
            const histogram = macdLine.map((val, index) => val - signalLine[index]);
            return { macd: macdLine.pop().toFixed(4), signal: signalLine.pop().toFixed(4), histogram: histogram.pop().toFixed(4) };
        }
        function calculateEMA(prices, period) {
            let ema = [];
            let multiplier = 2 / (period + 1);
            ema[0] = prices[0];
            for (let i = 1; i < prices.length; i++) {
                ema[i] = ((prices[i] - ema[i-1]) * multiplier) + ema[i-1];
            }
            return ema;
        }
        function calculateVolatility(highs, lows, closes) {
            if (highs.length < 15) return { volatility: 0, volatilityLabel: "Low", atr: 0 };
            let tr = [];
            for(let i = 1; i < highs.length; i++) {
                tr.push(Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i-1]), Math.abs(lows[i] - closes[i-1])));
            }
            const atr = tr.slice(-14).reduce((a,b) => a+b, 0) / 14;
            const volatility = (atr / closes[closes.length-1]) * 100;
            let label = "Low";
            if (volatility > 1.5) label = "High";
            else if (volatility > 0.7) label = "Medium";
            return { volatility: volatility.toFixed(2), volatilityLabel: label, atr };
        }
        
        function generateFundamentalAnalysis(trend, fearGreedData) {
            const sentimentText = `Fear & Greed Index is in '${fearGreedData.value_classification}' (${fearGreedData.value}).`;
            if (trend === 'Uptrend') {
                return {
                    keyDrivers: "Positive sentiment from recent ETF inflows and favorable regulatory news are supporting the price.",
                    marketSentiment: `${sentimentText} Retail is accumulating on dips, while institutional interest remains strong.`,
                    onChainMetrics: "Significant outflows from exchanges to private wallets suggest accumulation. Whale activity shows large buy orders."
                };
            } else if (trend === 'Downtrend') {
                return {
                    keyDrivers: "Macro-economic concerns (inflation, interest rates) are creating selling pressure. Negative regulatory rumors are circulating.",
                    marketSentiment: `${sentimentText} Retail is panic selling, while institutions are de-risking positions.`,
                    onChainMetrics: "Inflows to exchanges are increasing, suggesting holders are preparing to sell. Whale wallets are reducing their positions."
                };
            } else { // Sideways
                return {
                    keyDrivers: "Market is waiting for a clear catalyst from the upcoming Fed meeting. ETF flows have been flat for the past week.",
                    marketSentiment: `${sentimentText} Both buyers and sellers are hesitant, waiting for a clear direction.`,
                    onChainMetrics: "Exchange balances are stable. Whale activity is low, indicating major players are waiting on the sidelines."
                };
            }
        }

        // --- UI & Event Handlers ---
        function startPriceStream(pair) { 
            if (priceSocket) priceSocket.close();
            priceSocket = new WebSocket(`wss://stream.binance.com:9443/ws/${pair.toLowerCase()}@miniTicker`);
            priceSocket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                const newPrice = parseFloat(data.c);
                const priceElement = document.getElementById('current-price-value');
                const priceBox = document.getElementById('current-price-box');
                if (!priceElement || !priceBox) return;
                const oldPrice = parseFloat(priceElement.dataset.price || 0);
                const pricePrecision = newPrice > 10 ? 2 : 5;
                priceElement.textContent = `$${newPrice.toFixed(pricePrecision)}`;
                priceElement.dataset.price = newPrice;
                if (newPrice > oldPrice) priceBox.classList.add('price-up');
                else if (newPrice < oldPrice) priceBox.classList.add('price-down');
                setTimeout(() => priceBox.classList.remove('price-up', 'price-down'), 200);
            };
            priceSocket.onerror = (error) => {
                console.log("WebSocket connection event (this is normal during refresh):", error);
            };
        }
        function showLoader() { 
            if (priceSocket) priceSocket.close();
            signalContainer.innerHTML = `<div class="flex justify-center items-center p-10"><div class="loader"></div></div>`;
            historyContainer.innerHTML = `<div class="flex justify-center items-center p-10"><div class="loader"></div></div>`;
            topCoinsContainer.innerHTML = `<div class="flex justify-center items-center p-10"><div class="loader"></div></div>`;
            topMoversContainer.innerHTML = `<div class="flex justify-center items-center p-10"><div class="loader"></div></div>`;
            topLosersContainer.innerHTML = `<div class="flex justify-center items-center p-10"><div class="loader"></div></div>`;
            trendingCoinsTableContainer.innerHTML = `<div class="flex justify-center items-center p-10"><div class="loader"></div></div>`;
        }
        function showError(message) { 
            signalContainer.innerHTML = `<div class="text-center p-10 text-red-400"><i class="fas fa-exclamation-circle fa-2x mb-3"></i><h3 class="font-bold text-lg">Error</h3><p>${message}</p></div>`;
            historyContainer.innerHTML = `<div class="text-center p-10 text-red-400"><p>Could not load history.</p></div>`;
            topCoinsContainer.innerHTML = `<div class="text-center p-10 text-red-400"><p>Could not load market data.</p></div>`;
            topMoversContainer.innerHTML = `<div class="text-center p-10 text-red-400"><p>Could not load market data.</p></div>`;
            topLosersContainer.innerHTML = `<div class="text-center p-10 text-red-400"><p>Could not load market data.</p></div>`;
            trendingCoinsTableContainer.innerHTML = `<div class="text-center p-10 text-red-400"><p>Could not load trending data.</p></div>`;
        }
        async function handleFetch() {
            try {
                const pair = pairInput.value;
                const fearGreedResponse = await fetchWithRetry('https://api.alternative.me/fng/?limit=1');
                const fearGreedData = await fearGreedResponse.json();
                await updateGlobalDashboard(fearGreedData.data[0]);
                if(pair) getSignal(pair, currentInterval, currentTradeType, currentSpotType, fearGreedData.data[0]);
                updateTrendingCoinsTable();
            } catch (error) {
                console.error("Main fetch handler failed:", error);
                showError("Could not load initial market data. Please try refreshing.");
            }
        }
        fetchButton.addEventListener('click', handleFetch);
        refreshButton.addEventListener('click', handleFetch);
        pairInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') handleFetch(); });
        
        function updateTimeframeTabs(type) {
            const relevantTimeframes = timeframeMappings[type];
            timeframeTabsContainer.innerHTML = ''; 

            let activeFound = false;
            relevantTimeframes.forEach((interval) => {
                const button = document.createElement('button');
                button.className = 'tab';
                button.dataset.interval = interval;
                button.textContent = interval;
                if (interval === currentInterval) {
                    button.classList.add('active');
                    activeFound = true;
                }
                timeframeTabsContainer.appendChild(button);
            });

            if (!activeFound) {
                timeframeTabsContainer.children[0].classList.add('active');
                currentInterval = timeframeTabsContainer.children[0].dataset.interval;
            }
        }

        tradeTypeTabsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('tab')) {
                tradeTypeTabsContainer.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                e.target.classList.add('active');
                currentTradeType = e.target.dataset.type;
                if (currentTradeType === 'spot') {
                    spotSubTypeTabsContainer.style.display = 'flex';
                    updateTimeframeTabs(currentSpotType);
                } else {
                    spotSubTypeTabsContainer.style.display = 'none';
                    updateTimeframeTabs('all');
                }
                handleFetch();
            }
        });
        spotSubTypeTabsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('tab')) {
                spotSubTypeTabsContainer.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                e.target.classList.add('active');
                currentSpotType = e.target.dataset.spotType;
                updateTimeframeTabs(currentSpotType);
                handleFetch();
            }
        });
        timeframeTabsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('tab')) {
                timeframeTabsContainer.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                e.target.classList.add('active');
                currentInterval = e.target.dataset.interval;
                handleFetch();
            }
        });
        timezoneToggle.addEventListener('change', () => {
            currentTimezone = timezoneToggle.checked ? 'utc' : 'local';
            handleFetch();
        });
        
        // --- UI Update Functions ---
        function updateUI(data) {
            const pricePrecision = data.currentPrice > 10 ? 2 : 5;
            let tradeTypeClass = data.tradeType.includes('Long') ? 'tag-long' : data.tradeType.includes('Short') ? 'tag-short' : 'tag-neutral';
            
            signalContainer.innerHTML = `
                <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4">
                    <div>
                        <h2 class="text-2xl font-bold text-white">${data.pair} Signal</h2>
                        <p class="text-gray-400 text-sm mt-1">Last Analysis: ${formatTimestamp(data.timestamp).full}</p>
                    </div>
                    <div class="flex space-x-2 mt-3 sm:mt-0">
                        <span class="tag ${tradeTypeClass}">${data.tradeType}</span>
                        <span class="tag bg-purple-600 text-white">${data.trendDirection}</span>
                    </div>
                </div>
                <div class="justification-box"><i class="fas fa-lightbulb text-blue-300 fa-lg"></i><p class="text-sm text-gray-300">${data.justification}</p></div>
                
                <div class="grid grid-cols-3 gap-4 mb-4">
                    <div class="bg-gray-700/50 p-3 rounded-lg text-center">
                        <p class="text-xs text-gray-400">All-Time High</p>
                        <p class="font-semibold text-white">$${data.ath.toLocaleString()}</p>
                        <p class="text-xs font-medium text-red-400">${data.ath_change_percentage.toFixed(2)}%</p>
                        <p class="text-xs text-gray-500">${formatTimestamp(data.ath_date).fullDate}</p>
                    </div>
                    <div id="current-price-box" class="bg-gray-800 p-4 rounded-lg price-box text-center">
                        <p class="text-sm text-gray-400">Current Price</p>
                        <p id="current-price-value" data-price="${data.currentPrice}" class="text-3xl font-bold text-white">$${data.currentPrice.toFixed(pricePrecision)}</p>
                    </div>
                    <div class="bg-gray-700/50 p-3 rounded-lg text-center">
                        <p class="text-xs text-gray-400">All-Time Low</p>
                        <p class="font-semibold text-white">$${data.atl.toLocaleString()}</p>
                        <p class="text-xs font-medium text-green-400">+${data.atl_change_percentage.toFixed(2)}%</p>
                        <p class="text-xs text-gray-500">${formatTimestamp(data.atl_date).fullDate}</p>
                    </div>
                </div>

                <div class="bg-gray-800/50 rounded-lg p-4 mb-4">
                    <h3 class="text-lg font-semibold text-white mb-3">Trade Setup</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                        <div class="bg-red-900/50 p-3 rounded-lg"><p class="text-xs text-red-300">Stop Loss</p><p class="font-semibold text-red-300">$${data.stopLoss ? data.stopLoss.toFixed(pricePrecision) : 'N/A'}</p></div>
                        <div class="bg-green-900/50 p-3 rounded-lg"><p class="text-xs text-green-300">Take Profit 1</p><p class="font-semibold text-green-300">$${data.tp1 ? data.tp1.toFixed(pricePrecision) : 'N/A'}</p></div>
                        <div class="bg-green-900/50 p-3 rounded-lg"><p class="text-xs text-green-300">Take Profit 2</p><p class="font-semibold text-green-300">$${data.tp2 ? data.tp2.toFixed(pricePrecision) : 'N/A'}</p></div>
                        <div class="bg-green-900/50 p-3 rounded-lg"><p class="text-xs text-green-300">Take Profit 3</p><p class="font-semibold text-green-300">$${data.tp3 ? data.tp3.toFixed(pricePrecision) : 'N/A'}</p></div>
                    </div>
                    ${data.riskRewardRatio > 0 ? `<p class="text-center text-sm mt-3 text-blue-300">Risk/Reward Ratio (TP1): ~1:${data.riskRewardRatio}</p>` : ''}
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="space-y-4 analysis-section">
                        <h3 class="text-xl font-bold text-white"><i class="fas fa-chart-bar mr-2"></i>Technical Analysis</h3>
                        <div><h4>Support & Resistance</h4><p>Support: $${data.support.toFixed(pricePrecision)} | Resistance: $${data.resistance.toFixed(pricePrecision)}</p></div>
                        <div><h4>Indicators</h4><p>RSI: ${data.rsi.toFixed(2)} | MACD Hist: ${data.macd.histogram} | Volatility: ${data.volatilityLabel}</p></div>
                    </div>
                    <div class="space-y-4 analysis-section">
                        <h3 class="text-xl font-bold text-white"><i class="fas fa-globe-americas mr-2"></i>Fundamental Analysis</h3>
                        <div><h4>Key Drivers</h4><p>${data.keyDrivers}</p></div>
                        <div><h4>Market Sentiment</h4><p>${data.marketSentiment}</p></div>
                        <div><h4>On-Chain Metrics</h4><p>${data.onChainMetrics}</p></div>
                    </div>
                </div>`;
        }

        function updateHistoryTable(klines, pair, iconUrl) {
            const recentKlines = klines.slice(-12).reverse();
            const pricePrecision = parseFloat(recentKlines[0][4]) > 10 ? 2 : 5;
            let tableHTML = `<h3 class="text-xl font-bold text-white mb-4 flex items-center gap-2">
                                <img src="${iconUrl}" class="w-6 h-6 rounded-full">
                                ${pair.replace('USDT','')} History
                             </h3>
                             <div>
                                <table class="w-full compact-table">
                                    <thead><tr><th>Date</th><th>Time</th><th>Price</th><th>Change</th></tr></thead>
                                    <tbody>`;
            for (let i = 0; i < recentKlines.length - 1; i++) {
                const kline = recentKlines[i];
                const prevKline = recentKlines[i+1];
                const formatted = formatTimestamp(kline[0]);
                const price = parseFloat(kline[4]).toFixed(pricePrecision);
                const prevPrice = parseFloat(prevKline[4]);
                const change = ((price - prevPrice) / prevPrice * 100).toFixed(2);
                const changeColor = change >= 0 ? 'text-green-400' : 'text-red-400';
                tableHTML += `<tr><td>${formatted.date}</td><td>${formatted.time}</td><td>$${price}</td><td class="${changeColor}">${change}%</td></tr>`;
            }
            tableHTML += `</tbody></table></div>`;
            historyContainer.innerHTML = tableHTML;
        }

        async function updateMarketAnalysisTables(tradeType) {
            const topCoins = ['BTCUSDT', 'ETHUSDT', 'SOLUSDT', 'XRPUSDT', 'BNBUSDT', 'DOGEUSDT', 'ADAUSDT', 'AVAXUSDT', 'SHIBUSDT', 'DOTUSDT', 'LINKUSDT', 'MATICUSDT'];
            
            let topCoinsHtml = `<h3 class="text-xl font-bold text-white mb-4"><i class="fas fa-star mr-2"></i>Top Coins Analysis</h3><div><table class="w-full compact-table"><thead><tr><th>Coin</th><th>Price</th><th>Signal</th></tr></thead><tbody>`;
            let topMoversHtml = `<h3 class="text-xl font-bold text-white mb-4"><i class="fas fa-rocket mr-2"></i>Top Movers (24h)</h3><div><table class="w-full compact-table"><thead><tr><th>Coin</th><th>Change</th></tr></thead><tbody>`;
            let topLosersHtml = `<h3 class="text-xl font-bold text-white mb-4"><i class="fas fa-arrow-down mr-2"></i>Top Losers (24h)</h3><div><table class="w-full compact-table"><thead><tr><th>Coin</th><th>Change</th></tr></thead><tbody>`;

            try {
                // Use the cached market data if available
                if (!marketDataCache) {
                    const marketsResponse = await fetchWithRetry(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=1&sparkline=false&price_change_percentage=24h`);
                    marketDataCache = await marketsResponse.json();
                }
                const coingeckoData = marketDataCache;

                // --- 1. Populate Top Coins Analysis ---
                topCoins.forEach(coinSymbol => {
                    const symbol = coinSymbol.replace('USDT','').toLowerCase();
                    const coinData = coingeckoData.find(c => c.symbol === symbol);
                    if (!coinData) return;

                    const price = coinData.current_price;
                    const changePercent = coinData.price_change_percentage_24h;
                    
                    let signal = `<span class="tag tag-neutral">Neutral</span>`;
                    if (changePercent > 2.5) signal = `<span class="tag tag-strong-buy">Strong Buy</span>`;
                    else if (changePercent < -2.5) signal = `<span class="tag tag-strong-sell">Strong Sell</span>`;
                    else if (changePercent > 1) signal = `<span class="tag tag-long">Buy</span>`;
                    else if (changePercent < -1) signal = `<span class="tag tag-short">Sell</span>`;
                    
                    if (tradeType === 'spot' && (signal.includes('Sell') || signal.includes('short'))) {
                        signal = `<span class="tag tag-neutral">Neutral</span>`;
                    }

                    const pricePrecision = price > 10 ? 2 : 4;
                    topCoinsHtml += `<tr><td class="flex items-center gap-2"><img src="${coinData.image}" class="w-5 h-5 rounded-full">${coinData.symbol.toUpperCase()}</td><td>$${price.toFixed(pricePrecision)}</td><td>${signal}</td></tr>`;
                });


                // --- 2. Populate Top Movers & Losers from CoinGecko Data ---
                const validMovers = coingeckoData.filter(c => c.price_change_percentage_24h !== null && c.market_cap > 1000000);

                validMovers.sort((a, b) => b.price_change_percentage_24h - a.price_change_percentage_24h);
                validMovers.slice(0, 12).forEach(mover => {
                    const change = mover.price_change_percentage_24h;
                    topMoversHtml += `<tr><td class="flex items-center gap-2"><img src="${mover.image}" class="w-5 h-5 rounded-full">${mover.symbol.toUpperCase()}</td><td class="text-green-400">${change.toFixed(2)}%</td></tr>`;
                });

                validMovers.sort((a, b) => a.price_change_percentage_24h - b.price_change_percentage_24h);
                validMovers.slice(0, 12).forEach(loser => {
                    const change = loser.price_change_percentage_24h;
                    topLosersHtml += `<tr><td class="flex items-center gap-2"><img src="${loser.image}" class="w-5 h-5 rounded-full">${loser.symbol.toUpperCase()}</td><td class="text-red-400">${change.toFixed(2)}%</td></tr>`;
                });


            } catch (e) {
                console.error("Error in updateMarketAnalysisTables:", e);
                const errorRow = `<tr><td colspan="3">Error loading data</td></tr>`;
                topCoinsHtml += errorRow;
                topMoversHtml += errorRow.replace('colspan="3"', 'colspan="2"');
                topLosersHtml += errorRow.replace('colspan="3"', 'colspan="2"');
            }
            
            topCoinsHtml += `</tbody></table></div>`;
            topMoversHtml += `</tbody></table></div>`;
            topLosersHtml += `</tbody></table></div>`;

            topCoinsContainer.innerHTML = topCoinsHtml;
            topMoversContainer.innerHTML = topMoversHtml;
            topLosersContainer.innerHTML = topLosersHtml;
        }

        async function updateTrendingCoinsTable() {
            const trendingContainer = document.getElementById('trending-coins-table-container');
            let trendingHtml = `<h3 class="text-xl font-bold text-white mb-4"><i class="fas fa-fire mr-2"></i>Trending Coins</h3>
                                <div><table class="w-full compact-table"><thead><tr><th>Coin</th><th>Price</th><th>24h %</th><th>Signal</th></tr></thead><tbody>`;
            try {
                const trendingRes = await fetchWithRetry('https://api.coingecko.com/api/v3/search/trending');
                const trendingData = await trendingRes.json();
                const coinIds = trendingData.coins.map(c => c.item.id).join(',');

                const marketsRes = await fetchWithRetry(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinIds}&order=market_cap_desc&per_page=7&page=1&sparkline=false&price_change_percentage=24h`);
                const marketsData = await marketsRes.json();

                marketsData.forEach(coin => {
                    const price = coin.current_price;
                    const change = coin.price_change_percentage_24h;
                    const changeColor = change >= 0 ? 'text-green-400' : 'text-red-400';
                    const pricePrecision = price > 10 ? 2 : 4;
                    
                    let signal = `<span class="tag tag-neutral">Neutral</span>`;
                    if (change > 1) signal = `<span class="tag tag-long">Buy</span>`;
                    else if (change < -1) signal = `<span class="tag tag-neutral">Hold</span>`;

                    trendingHtml += `<tr>
                        <td class="flex items-center gap-2"><img src="${coin.image}" class="w-5 h-5 rounded-full">${coin.symbol.toUpperCase()}</td>
                        <td>$${price.toFixed(pricePrecision)}</td>
                        <td class="${changeColor}">${change.toFixed(2)}%</td>
                        <td>${signal}</td>
                    </tr>`;
                });
            } catch (e) {
                trendingHtml += `<tr><td colspan="4">Error loading data</td></tr>`;
            }
            trendingHtml += `</tbody></table></div>`;
            trendingContainer.innerHTML = trendingHtml;
        }
        
        async function updateGlobalDashboard(fearGreedData) {
            const marketCapEl = document.getElementById('market-cap');
            const marketCapChangeEl = document.getElementById('market-cap-change');
            const volume24hEl = document.getElementById('volume-24h');
            const volumeChangeEl = document.getElementById('volume-change');
            const dominanceContainer = document.getElementById('dominance-container');
            const dominanceBar = document.getElementById('dominance-bar');
            const fearGreedValueEl = document.getElementById('fear-greed-value');
            const fearGreedTextEl = document.getElementById('fear-greed-text');
            const fearGreedChartCanvas = document.getElementById('fear-greed-chart');
            const advancersEl = document.getElementById('advancers');
            const declinersEl = document.getElementById('decliners');


            const API_BASE_URL = 'https://api.coingecko.com/api/v3';

            const formatLargeNumber = (value) => {
                if (!value) return '-';
                if (value > 1_000_000_000_000) return `$${(value / 1_000_000_000_000).toFixed(2)} T`;
                if (value > 1_000_000_000) return `$${(value / 1_000_000_000).toFixed(2)} B`;
                return `$${(value / 1_000_000).toFixed(2)} M`;
            };

            const formatPercentage = (value, element) => {
                if (value === null || typeof value === 'undefined' || isNaN(value)) {
                    element.textContent = 'N/A';
                    return;
                };
                element.textContent = `${value >= 0 ? '+' : ''}${value.toFixed(2)}%`;
                element.className = `text-sm font-medium ${value >= 0 ? 'text-green-400' : 'text-red-400'}`;
            };

            try {
                const globalResponse = await fetchWithRetry(`${API_BASE_URL}/global`);
                await new Promise(resolve => setTimeout(resolve, 250)); 
                const marketsResponse = await fetchWithRetry(`${API_BASE_URL}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=1&sparkline=false&price_change_percentage=24h`);
                marketDataCache = await marketsResponse.json();
                
                const globalData = await globalResponse.json();
                
                coinIconMap = {};
                marketDataCache.forEach(coin => {
                    coinIconMap[coin.symbol.toUpperCase()] = coin.image;
                });
                
                const data = globalData.data;
                marketCapEl.textContent = formatLargeNumber(data.total_market_cap.usd);
                formatPercentage(data.market_cap_change_percentage_24h_usd, marketCapChangeEl);
                volume24hEl.textContent = formatLargeNumber(data.total_volume.usd);
                formatPercentage(null, volumeChangeEl);

                const fearGreedValue = fearGreedData;
                fearGreedValueEl.textContent = fearGreedValue.value;
                fearGreedTextEl.textContent = fearGreedValue.value_classification;
                
                if (fearGreedChart) fearGreedChart.destroy();
                fearGreedChart = new Chart(fearGreedChartCanvas, {
                    type: 'doughnut', data: { datasets: [{ data: [25, 20, 10, 20, 25], backgroundColor: ['#f43f5e', '#f97316', '#eab308', '#84cc16', '#22c55e'], borderWidth: 0, }, { data: [fearGreedValue.value, 100 - fearGreedValue.value], backgroundColor: ['#e5e7eb', 'transparent'], borderWidth: 0, circumference: 10, rotation: (fearGreedValue.value / 100) * 180 - 90 - 5, }] }, options: { responsive: true, maintainAspectRatio: false, cutout: '80%', circumference: 180, rotation: -90, plugins: { legend: { display: false }, tooltip: { enabled: false } } }
                });

                const btcDom = data.market_cap_percentage.btc;
                const ethDom = data.market_cap_percentage.eth;
                const othersDom = 100 - btcDom - ethDom;
                
                const btcData = marketDataCache.find(c => c.id === 'bitcoin');
                const ethData = marketDataCache.find(c => c.id === 'ethereum');
                
                const btcChange = btcData ? btcData.price_change_percentage_24h : 0;
                const ethChange = ethData ? ethData.price_change_percentage_24h : 0;
                const othersChange = data.market_cap_change_percentage_24h_usd;

                const btcChangeColor = btcChange >= 0 ? 'text-green-400' : 'text-red-400';
                const ethChangeColor = ethChange >= 0 ? 'text-green-400' : 'text-red-400';
                const othersChangeColor = othersChange >= 0 ? 'text-green-400' : 'text-red-400';
                
                const btcArrow = btcChange >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';
                const ethArrow = ethChange >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';
                const othersArrow = othersChange >= 0 ? 'fa-arrow-up' : 'fa-arrow-down';

                dominanceContainer.innerHTML = `
                    <div class="flex justify-between items-center text-xs text-gray-500 mb-1">
                        <span>Coin</span>
                        <div class="flex items-center text-right">
                            <span class="w-12">Dom %</span>
                            <span class="w-20">24H Change</span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-bold text-amber-500">Bitcoin</span>
                        <div class="flex items-center">
                            <span class="text-sm font-semibold text-white w-12 text-right">${btcDom.toFixed(1)}%</span>
                            <span class="text-xs font-medium ${btcChangeColor} flex items-center justify-end gap-1 w-20">
                                ${btcChange.toFixed(2)}% <i class="fas ${btcArrow}"></i>
                            </span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-bold text-indigo-400">Ethereum</span>
                        <div class="flex items-center">
                            <span class="text-sm font-semibold text-white w-12 text-right">${ethDom.toFixed(1)}%</span>
                            <span class="text-xs font-medium ${ethChangeColor} flex items-center justify-end gap-1 w-20">
                                ${ethChange.toFixed(2)}% <i class="fas ${ethArrow}"></i>
                            </span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-xs font-bold text-gray-400">Others</span>
                        <div class="flex items-center">
                            <span class="text-sm font-semibold text-white w-12 text-right">${othersDom.toFixed(1)}%</span>
                            <span class="text-xs font-medium ${othersChangeColor} flex items-center justify-end gap-1 w-20">
                                ${othersChange.toFixed(2)}% <i class="fas ${othersArrow}"></i>
                            </span>
                        </div>
                    </div>`;
                dominanceBar.innerHTML = `<div class="bg-amber-500" style="width: ${btcDom}%"></div><div class="bg-indigo-400" style="width: ${ethDom}%"></div><div class="bg-gray-400" style="width: ${othersDom}%"></div>`;

                let advancersCount = 0;
                marketDataCache.forEach(coin => {
                    if (coin.price_change_percentage_24h != null && coin.price_change_percentage_24h >= 0) advancersCount++;
                });
                advancersEl.textContent = `${advancersCount} Advancers`;
                declinersEl.textContent = `${marketDataCache.length - advancersCount} Decliners`;

            } catch (e) {
                console.error("Error updating global dashboard:", e);
                marketOverview.innerHTML = `<div class="col-span-1 sm:col-span-2 lg:col-span-4 text-red-400 text-sm p-4 text-center">Could not load market dashboard data.</div>`;
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            updateTimeframeTabs(currentSpotType);
            await handleFetch();
        });
    </script>
</body>
</html>
